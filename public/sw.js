const STATIC_CACHE = 'static-cache-v2';
const DYNAMIC_CACHE = 'dynamic-cache-v2';

// Assets to cache immediately
const STATIC_ASSETS = [
  '/',
  '/index.html',
  '/manifest.json',
  // Add your main JS/CSS bundles here (will be generated by Vite)
];

// Cache strategies
const CACHE_STRATEGIES = {
  // Cache static assets for 1 year
  STATIC: { maxAge: 365 * 24 * 60 * 60 * 1000 },
  // Cache images for 30 days  
  IMAGES: { maxAge: 30 * 24 * 60 * 60 * 1000 },
  // Cache API responses for 1 hour
  API: { maxAge: 60 * 60 * 1000 }
};

// Install event - cache static assets
self.addEventListener('install', event => {
  event.waitUntil(
    caches.open(STATIC_CACHE).then(cache => {
      return cache.addAll(STATIC_ASSETS);
    })
  );
  self.skipWaiting();
});

// Activate event - clean up old caches
self.addEventListener('activate', event => {
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.map(cacheName => {
          if (cacheName !== STATIC_CACHE && cacheName !== DYNAMIC_CACHE) {
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
  self.clients.claim();
});

// Fetch event - implement caching strategies
self.addEventListener('fetch', event => {
  const { request } = event;

  // Handle images with long-term caching
  if (request.url.includes('/images/')) {
    event.respondWith(handleImageCache(request));
  }
  // Handle JS/CSS assets
  else if (request.destination === 'script' || request.destination === 'style') {
    event.respondWith(handleStaticAssets(request));
  }
  // Handle HTML pages
  else if (request.destination === 'document') {
    event.respondWith(handleDocumentCache(request));
  }
  // Handle other requests
  else {
    event.respondWith(handleDynamicCache(request));
  }
});

// Image caching strategy - Cache First
async function handleImageCache(request) {
  const cache = await caches.open(DYNAMIC_CACHE);
  const cached = await cache.match(request);

  if (cached) {
    // Check if cache is still valid
    const cachedDate = new Date(cached.headers.get('date'));
    const now = new Date();
    const age = now.getTime() - cachedDate.getTime();

    if (age < CACHE_STRATEGIES.IMAGES.maxAge) {
      return cached;
    }
  }

  try {
    const response = await fetch(request);
    if (response.ok) {
      // Add timestamp header for cache validation
      const responseClone = response.clone();
      const headers = new Headers(responseClone.headers);
      headers.set('date', new Date().toISOString());
      headers.set('cache-control', 'max-age=2592000'); // 30 days

      const modifiedResponse = new Response(responseClone.body, {
        status: responseClone.status,
        statusText: responseClone.statusText,
        headers: headers
      });

      cache.put(request, modifiedResponse.clone());
      return modifiedResponse;
    }
    return response;
  } catch {
    return cached || new Response('Image not available', { status: 404 });
  }
}

// Static assets strategy - Cache First with long expiry
async function handleStaticAssets(request) {
  const cache = await caches.open(STATIC_CACHE);
  const cached = await cache.match(request);

  if (cached) {
    return cached;
  }

  try {
    const response = await fetch(request);
    if (response.ok) {
      cache.put(request, response.clone());
    }
    return response;
  } catch {
    return cached || new Response('Asset not available', { status: 404 });
  }
}

// Document caching strategy - Network First
async function handleDocumentCache(request) {
  try {
    const response = await fetch(request);
    if (response.ok) {
      const cache = await caches.open(DYNAMIC_CACHE);
      cache.put(request, response.clone());
    }
    return response;
  } catch {
    const cache = await caches.open(DYNAMIC_CACHE);
    const cached = await cache.match(request);
    return cached || new Response('Page not available offline', { status: 404 });
  }
}

// Dynamic content strategy - Network First with fallback
async function handleDynamicCache(request) {
  try {
    const response = await fetch(request);
    if (response.ok) {
      const cache = await caches.open(DYNAMIC_CACHE);
      cache.put(request, response.clone());
    }
    return response;
  } catch {
    const cache = await caches.open(DYNAMIC_CACHE);
    return cache.match(request) || new Response('Content not available', { status: 404 });
  }
}